package com.justdavis.jessentials.jversionsanity.util;

import com.justdavis.jessentials.jversionsanity.Version;

/**
 * Models the components of a <a href=
 * "http://en.wikipedia.org/wiki/Interval_%28mathematics%29" >mathematical
 * interval</a>, which is used by some components of this library to express
 * version ranges.
 * 
 * @param <V>
 *            the type of {@link Object} being used to represent the version,
 *            which will typically either be a {@link String} representation of
 *            a version or an actual {@link Version} implementation
 */
public final class Interval<V extends Object> {
	private final IntervalBoundaryType typeLower;
	private final V versionLower;
	private final V versionUpper;
	private final IntervalBoundaryType typeUpper;

	/**
	 * Constructor for {@link Interval}s where {@link #isSingleValued()} is
	 * <code>false</code>.
	 * 
	 * @param typeLower
	 *            the value to use for {@link #getTypeLower()}
	 * @param versionLower
	 *            the value to use for {@link #getVersionLower()}
	 * @param versionUpper
	 *            the value to use for {@link #getVersionUpper()}
	 * @param typeUpper
	 *            the value to use for {@link #getTypeUpper()}
	 */
	public Interval(IntervalBoundaryType typeLower, V versionLower,
			V versionUpper, IntervalBoundaryType typeUpper) {
		// Sanity check: nulls
		if (typeLower == null)
			throw new IllegalArgumentException();
		if (typeUpper == null)
			throw new IllegalArgumentException();

		// Sanity check: unbalanced boundary types
		if ((typeLower == IntervalBoundaryType.OMITTED) != (typeUpper == IntervalBoundaryType.OMITTED))
			throw new IllegalArgumentException(
					"Only zero or both boundary types may be omitted.");

		// Sanity check: at least one version boundary
		if (versionLower == null && versionUpper == null)
			throw new IllegalArgumentException(
					"At least the lower or upper version must be specified.");

		// Sanity check: if boundary types omitted, upper version must be
		// also
		if ((typeLower == IntervalBoundaryType.OMITTED)
				&& (versionUpper != null))
			throw new IllegalArgumentException(
					"Upper version may not be provided if boundary types are omitted.");

		this.typeLower = typeLower;
		this.versionLower = versionLower;
		this.versionUpper = versionUpper;
		this.typeUpper = typeUpper;
	}

	/**
	 * Constructor for {@link Interval}s where {@link #isSingleValued()} is
	 * <code>true</code>.
	 * 
	 * @param typeLower
	 *            the value to use for {@link #getTypeLower()}
	 * @param version
	 *            the value to use for {@link #getVersionLower()}
	 * @param typeUpper
	 *            the value to use for {@link #getTypeUpper()}
	 */
	public Interval(IntervalBoundaryType typeLower, V version,
			IntervalBoundaryType typeUpper) {
		this(typeLower, version, version, typeUpper);
	}

	/**
	 * @return the left/lower {@link IntervalBoundaryType} constant
	 */
	public IntervalBoundaryType getTypeLower() {
		return typeLower;
	}

	/**
	 * @return the left/lower version, or <code>null</code> if this end of the
	 *         range is left unbound
	 */
	public V getVersionLower() {
		return versionLower;
	}

	/**
	 * @return the right/upper version, or <code>null</code> if this end of the
	 *         range is left unbound
	 */
	public V getVersionUpper() {
		return versionUpper;
	}

	/**
	 * @return the right/upper {@link IntervalBoundaryType} constant
	 */
	public IntervalBoundaryType getTypeUpper() {
		return typeUpper;
	}

	/**
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		/*
		 * This method was generated by Eclipse's 'Source > Generate hashCode()
		 * and equals()...' feature.
		 */

		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((typeLower == null) ? 0 : typeLower.hashCode());
		result = prime * result
				+ ((typeUpper == null) ? 0 : typeUpper.hashCode());
		result = prime * result
				+ ((versionLower == null) ? 0 : versionLower.hashCode());
		result = prime * result
				+ ((versionUpper == null) ? 0 : versionUpper.hashCode());
		return result;
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		/*
		 * This method was generated by Eclipse's 'Source > Generate hashCode()
		 * and equals()...' feature.
		 */

		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Interval<?> other = (Interval<?>) obj;
		if (typeLower != other.typeLower)
			return false;
		if (typeUpper != other.typeUpper)
			return false;
		if (versionLower == null) {
			if (other.versionLower != null)
				return false;
		} else if (!versionLower.equals(other.versionLower))
			return false;
		if (versionUpper == null) {
			if (other.versionUpper != null)
				return false;
		} else if (!versionUpper.equals(other.versionUpper))
			return false;
		return true;
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuilder rangeString = new StringBuilder();

		Character boundaryLower = this.typeLower.getSymbolForLowerBoundary();
		if (boundaryLower != null)
			rangeString.append(boundaryLower);
		if (this.versionLower != null)
			rangeString.append(this.versionLower);
		if (this.typeLower != IntervalBoundaryType.OMITTED)
			rangeString.append(',');
		if (this.versionUpper != null)
			rangeString.append(this.versionUpper);
		Character boundaryUpper = this.typeUpper.getSymbolForUpperBoundary();
		if (boundaryUpper != null)
			rangeString.append(boundaryUpper);

		return rangeString.toString();
	}
}