package com.justdavis.jessentials.jversionsanity.bareint;

import com.justdavis.jessentials.jversionsanity.VersionParseException;
import com.justdavis.jessentials.jversionsanity.VersionRange;
import com.justdavis.jessentials.jversionsanity.VersionRangeParseException;
import com.justdavis.jessentials.jversionsanity.util.Interval;
import com.justdavis.jessentials.jversionsanity.util.IntervalBoundaryType;
import com.justdavis.jessentials.jversionsanity.util.IntervalMatcher;
import com.justdavis.jessentials.jversionsanity.util.IntervalParser;

/**
 * <p>
 * The {@link VersionRange} implementation for {@link IntegerVersion}. It
 * supports basic <a href=
 * "http://en.wikipedia.org/wiki/Interval_%28mathematics%29#Notations_for_intervals"
 * >interval notation</a>, as documented in {@link IntervalParser}.
 * </p>
 * <p>
 * This {@link IntegerVersionRange} ranges follow the semantics specified in
 * {@link IntervalParser}; see that class for more details.
 * </p>
 */
public final class IntegerVersionRange implements VersionRange<IntegerVersion> {
	/**
	 * Stores the {@link String} that this {@link IntegerVersionRange} instance
	 * was parsed from, or <code>null</code> if it was constructed manually.
	 */
	private final String rangeString;

	private final Interval<IntegerVersion> interval;

	/**
	 * Parses an {@link IntegerVersionRange} from the specified {@link String}
	 * representation.
	 * 
	 * @param rangeString
	 *            a {@link String} representation of an
	 *            {@link IntegerVersionRange}, e.g. as produced by
	 *            {@link #toString()}
	 * @throws VersionRangeParseException
	 *             A {@link VersionRangeParseException} will be thrown if the
	 *             specified {@link String} cannot be parsed.
	 */
	public IntegerVersionRange(String rangeString)
			throws VersionRangeParseException {
		if (rangeString == null)
			throw new IllegalArgumentException(
					"Null range strings not supported.");

		this.rangeString = rangeString;

		IntervalParser parser = new IntervalParser();
		Interval<String> parsedStringInterval = parser
				.parseVersionRange(rangeString);

		try {
			IntegerVersion versionLower;
			if (parsedStringInterval.getVersionLower() != null)
				versionLower = new IntegerVersion(
						parsedStringInterval.getVersionLower());
			else
				versionLower = null;

			IntegerVersion versionUpper;
			if (parsedStringInterval.getVersionUpper() != null)
				versionUpper = new IntegerVersion(
						parsedStringInterval.getVersionUpper());
			else
				versionUpper = null;

			// Sanity check: ensure that the versions aren't backwards
			if (versionLower != null && versionUpper != null
					&& versionLower.compareTo(versionUpper) > 0)
				throw new IllegalArgumentException(
						"The 'lower' version is actually greater than the 'upper' version.");

			this.interval = new Interval<IntegerVersion>(
					parsedStringInterval.getTypeLower(), versionLower,
					versionUpper, parsedStringInterval.getTypeUpper());
		} catch (VersionParseException e) {
			throw new VersionRangeParseException(rangeString, this.getClass(),
					e);
		}
	}

	/**
	 * Constructs a new {@link IntegerVersionRange}.
	 * 
	 * @param boundaryLower
	 *            the {@link IntervalBoundaryType} constant for the lower
	 *            boundary of this {@link IntegerVersionRange}
	 * @param versionLower
	 *            the {@link IntegerVersion} that represents the version for the
	 *            lower boundary of this {@link IntegerVersionRange}, or
	 *            <code>null</code> if the range has no lower bound
	 * @param versionUpper
	 *            the {@link IntegerVersion} that represents the version for the
	 *            upper boundary of this {@link IntegerVersionRange}, or
	 *            <code>null</code> if the range has no upper bound
	 * @param boundaryUpper
	 *            the {@link IntervalBoundaryType} constant for the upper
	 *            boundary of this {@link IntegerVersionRange}
	 */
	public IntegerVersionRange(IntervalBoundaryType boundaryLower,
			IntegerVersion versionLower, IntegerVersion versionUpper,
			IntervalBoundaryType boundaryUpper) {
		// Sanity check: ensure that the versions aren't backwards
		if (versionLower != null && versionUpper != null
				&& versionLower.compareTo(versionUpper) > 0)
			throw new IllegalArgumentException(
					"The 'lower' version is actually greater than the 'upper' version.");

		this.rangeString = null;
		this.interval = new Interval<IntegerVersion>(boundaryLower,
				versionLower, versionUpper, boundaryUpper);
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		if (rangeString != null)
			return rangeString;
		else
			return interval.toString();
	}

	/**
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		/*
		 * This method was generated by Eclipse's 'Source > Generate hashCode()
		 * and equals()...' feature.
		 */

		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((interval == null) ? 0 : interval.hashCode());
		return result;
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		/*
		 * This method was generated by Eclipse's 'Source > Generate hashCode()
		 * and equals()...' feature.
		 */

		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		IntegerVersionRange other = (IntegerVersionRange) obj;
		if (interval == null) {
			if (other.interval != null)
				return false;
		} else if (!interval.equals(other.interval))
			return false;
		return true;
	}

	/**
	 * @see com.justdavis.jessentials.jversionsanity.VersionRange#matches(com.justdavis.jessentials.jversionsanity.Version)
	 */
	@Override
	public boolean matches(IntegerVersion version) {
		/*
		 * There are basically two ways to implement this: A) as a collection of
		 * edge cases, with lots of if-else blocks, or B) as predicate logic.
		 * Option (B) is a lot easier to read, so I've opted for it, even though
		 * it requires the use of Hamcrest (or some hand-written predicate logic
		 * classes).
		 */
		return new IntervalMatcher<IntegerVersion>(interval).matches(version);
	}
}
