package com.justdavis.jessentials.jversionsanity;

import org.junit.Assert;
import org.junit.Test;

/**
 * <p>
 * A set of unit tests that all {@link VersionRange} implementations
 * <strong>must</strong> pass. Extend this class, implement all required
 * methods, and ensure that the tests are run as part of the build.
 * </p>
 * <p>
 * Please note that these tests are not intended to be <em>sufficient</em> for
 * any {@link VersionRange} implementations; they only represent a mandatory
 * <em>subset</em> of the tests required to verify that an implementation
 * behaves correctly. In other words: write more tests.
 * </p>
 * 
 * @param <V>
 *            the {@link Version} implementation that the {@link VersionRange}
 *            implementation being tested is associated with
 */
public abstract class AbstractVersionRangeTest<V extends Version> {
	/**
	 * @return the {@link VersioningScheme} of the {@link VersionRange}
	 *         implementation being tested
	 */
	protected abstract VersioningScheme getVersioningScheme();

	/**
	 * Generates a sample instance of the {@link VersionRange} implementation
	 * being tested. Must return a new instance every time. This instance must
	 * not be equivalent to those generated by {@link #getSample2()}.
	 * 
	 * @return a sample instance of the {@link VersionRange} implementation
	 *         being tested
	 */
	protected abstract VersionRange<V> getSample1();

	/**
	 * @return a {@link String} representation equivalent to the
	 *         {@link VersionRange} returned by {@link #getSample1()}
	 */
	protected abstract String getSample1String();

	/**
	 * @return a {@link Version} that is supposed to match the
	 *         {@link VersionRange} specified in {@link #getSample1()}
	 */
	protected abstract V getSample1VersionMatching();

	/**
	 * @return a {@link Version} that is not supposed to match the
	 *         {@link VersionRange} specified in {@link #getSample1()}
	 */
	protected abstract V getSample1VersionNotMatching();

	/**
	 * Generates a sample instance of the {@link VersionRange} implementation
	 * being tested. Must return a new instance every time. This instance must
	 * not be equivalent to those generated by {@link #getSample1()}.
	 * 
	 * @return a sample instance of the {@link VersionRange} implementation
	 *         being tested
	 */
	protected abstract VersionRange<V> getSample2();

	/**
	 * @return the {@link VersionRange} implementation being tested
	 */
	protected final Class<? extends VersionRange<?>> getRangeImplementation() {
		return getVersioningScheme().getRangeImpl();
	}

	/**
	 * Ensures that the {@link VersionRange} implementation has the required
	 * parse constructor.
	 * 
	 * @throws NoSuchMethodException
	 *             This exception indicates that the required parse constructor
	 *             is missing.
	 * @throws SecurityException
	 *             (should not be thrown)
	 */
	@Test
	public final void hasParseConstructor() throws SecurityException,
			NoSuchMethodException {
		// This will throw an exception if the constructor is missing.
		getRangeImplementation().getConstructor(String.class);
	}

	/**
	 * Ensures that the {@link VersionRange} implementation implements
	 * {@link Object#equals(Object)} and {@link Object#hashCode()} correctly,
	 * testing it against {@link #getSample1()} and {@link #getSample2()}.
	 */
	@Test
	public final void equalsAndHashCodeWorksCorrectly() {
		VersionRange<?> sample1 = getSample1();

		Assert.assertEquals(sample1, sample1);
		Assert.assertEquals(sample1.hashCode(), sample1.hashCode());

		Assert.assertEquals(sample1, getSample1());
		Assert.assertEquals(sample1.hashCode(), getSample1().hashCode());

		Assert.assertNotEquals(getSample1(), getSample2());
		/*
		 * Note: there's no requirement that hasCode() return different values
		 * for inequal objects; some hashes may collide.
		 */
	}

	/**
	 * Ensures that the {@link VersionRange} implementation's parse constructor
	 * works correctly on the sample in {@link #getSample1String()}.
	 */
	@Test
	public final void canParseSuccessfully() {
		VersionParser parser = new VersionParser();

		VersionRange<?> parsedRange = parser.parseRange(getVersioningScheme(),
				getSample1String());
		Assert.assertNotNull(parsedRange);
		Assert.assertEquals(getSample1(), parsedRange);
	}

	/**
	 * Ensures that the {@link VersionRange} implementation implements
	 * {@link #toString()} correctly, testing it against a {@link VersionRange}
	 * instance parsed from {@link #getSample1String()}.
	 */
	@Test
	public final void toStringWorksCorrectly() {
		VersionRange<?> sample1 = new VersionParser().parseRange(
				getVersioningScheme(), getSample1String());

		Assert.assertEquals(getSample1String(), sample1.toString());
		Assert.assertNotEquals(sample1.toString(), getSample2().toString());
	}

	/**
	 * Ensures that the {@link VersionRange} implementation implements
	 * {@link #toString()} correctly, testing it against a {@link VersionRange}
	 * instance parsed from {@link #getSample1String()}.
	 */
	@Test
	public final void matches() {
		Assert.assertTrue(getSample1().matches(getSample1VersionMatching()));
		Assert.assertFalse(getSample1().matches(getSample1VersionNotMatching()));
	}
}
