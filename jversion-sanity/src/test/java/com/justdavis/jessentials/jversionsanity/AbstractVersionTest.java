package com.justdavis.jessentials.jversionsanity;

import org.junit.Assert;
import org.junit.Test;

/**
 * <p>
 * A set of unit tests that all {@link Version} implementations
 * <strong>must</strong> pass. Extend this class, implement all required
 * methods, and ensure that the tests are run as part of the build.
 * </p>
 * <p>
 * Please note that these tests are not intended to be <em>sufficient</em> for
 * any {@link Version} implementations; they only represent a mandatory
 * <em>subset</em> of the tests required to verify that an implementation
 * behaves correctly. In other words: write more tests.
 * </p>
 * <p>
 * Some test coverage is also provided for the {@link VersionParser}
 * implementation associated with the {@link Version} implementation. Again
 * though, more coverage is likely needed.
 * </p>
 * 
 * @param <V>
 *            the {@link Version} implementation that is being tested
 */
public abstract class AbstractVersionTest<V extends Version> {
	/**
	 * @return the {@link VersionParser} for the {@link Version} implementation
	 *         being tested
	 */
	protected abstract VersionParser<V> getParser();

	/**
	 * Generates a sample instance of the {@link Version} implementation being
	 * tested. Must return a new instance every time. This instance must not be
	 * equivalent to those generated by {@link #getSample2()}, and must be
	 * "less" than it, for purposes of calls to
	 * {@link Comparable#compareTo(Object)}.
	 * 
	 * @return a sample instance of the {@link Version} implementation being
	 *         tested
	 */
	protected abstract V getSample1();

	/**
	 * @return a {@link String} representation equivalent to the {@link Version}
	 *         returned by {@link #getSample1()}
	 */
	protected abstract String getSample1String();

	/**
	 * Generates a sample instance of the {@link Version} implementation being
	 * tested. Must return a new instance every time. This instance must not be
	 * equivalent to those generated by {@link #getSample1()}, and must be
	 * "greater" than it, for purposes of calls to
	 * {@link Comparable#compareTo(Object)}.
	 * 
	 * @return a sample instance of the {@link Version} implementation being
	 *         tested
	 */
	protected abstract V getSample2();

	/**
	 * @return the {@link Version} implementation being tested
	 */
	protected final Class<?> getVersionImplementation() {
		return getSample1().getClass();
	}

	/**
	 * Ensures that the {@link Version} implementation has the required parse
	 * constructor.
	 * 
	 * @throws NoSuchMethodException
	 *             This exception indicates that the required parse constructor
	 *             is missing.
	 * @throws SecurityException
	 *             (should not be thrown)
	 */
	@Test
	public final void hasParseConstructor() throws SecurityException, NoSuchMethodException {
		// This will throw an exception if the constructor is missing.
		getVersionImplementation().getConstructor(String.class);
	}

	/**
	 * Ensures that the {@link Version} implementation implements
	 * {@link Object#equals(Object)} and {@link Object#hashCode()} correctly,
	 * testing it against {@link #getSample1()} and {@link #getSample2()}.
	 */
	@Test
	public final void equalsAndHashCodeWorksCorrectly() {
		Version sample1 = getSample1();

		Assert.assertEquals(sample1, sample1);
		Assert.assertEquals(sample1.hashCode(), sample1.hashCode());

		Assert.assertEquals(sample1, getSample1());
		Assert.assertEquals(sample1.hashCode(), getSample1().hashCode());

		Assert.assertNotEquals(getSample1(), getSample2());
		/*
		 * Note: there's no requirement that hasCode() return different values
		 * for inequal objects; some hashes may collide.
		 */
	}

	/**
	 * Ensures that the {@link Version} implementation's parse constructor works
	 * correctly on the sample in {@link #getSample1String()}.
	 */
	@Test
	public final void canParseSuccessfully() {
		String versionString = getSample1String();

		Version parsedVersion = getParser().parseVersion(versionString);
		Assert.assertNotNull(parsedVersion);
		Assert.assertEquals(getSample1(), parsedVersion);
	}

	/**
	 * Ensures that the {@link Version} implementation implements
	 * {@link #toString()} correctly, testing it against a {@link Version}
	 * instance parsed from {@link #getSample1String()}.
	 */
	@Test
	public final void toStringWorksCorrectly() {
		Version sample1 = getParser().parseVersion(getSample1String());

		Assert.assertEquals(getSample1String(), sample1.toString());
		Assert.assertNotEquals(sample1.toString(), getSample2().toString());
	}

	/**
	 * Ensures that the {@link Version} implementation implements
	 * {@link Comparable#compareTo(Object)} correctly, testing it against
	 * {@link #getSample1()} and {@link #getSample2()}.
	 */
	@Test
	public final void compareToWorksCorrectly() {
		Version sample1 = getSample1();
		Version sample2 = getSample2();

		Assert.assertTrue(sample1.compareTo(getSample1()) == 0);
		Assert.assertTrue(sample1.compareTo(getSample2()) < 0);
		Assert.assertTrue(sample2.compareTo(getSample1()) > 0);
	}
}
